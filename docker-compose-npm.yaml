# ==================================================================
# Docker Compose dla Dify + Nginx Proxy Manager + Portainer CE
#
# KONFIGURACJA: Zhardkodowana (porty, hosty, ustawienia)
# SEKRETY: Jako zmienne środowiskowe z Portainer UI
# ==================================================================

x-shared-env: &shared-api-worker-env
  # URLs - puste, używamy tej samej domeny przez Nginx Proxy Manager
  CONSOLE_API_URL: ""
  CONSOLE_WEB_URL: ""
  SERVICE_API_URL: ""
  APP_API_URL: ""
  APP_WEB_URL: ""
  FILES_URL: ""
  INTERNAL_FILES_URL: ""

  # Server Configuration - stałe wartości
  LOG_LEVEL: INFO
  DEBUG: "false"
  FLASK_DEBUG: "false"

  # SEKRETY - z Portainer UI
  SECRET_KEY: ${SECRET_KEY}

  # Database - stałe + sekret
  DB_USERNAME: postgres
  DB_HOST: db
  DB_PORT: 5432
  DB_DATABASE: dify
  # SEKRET:
  DB_PASSWORD: ${DB_PASSWORD}

  # Redis - stałe + sekret
  REDIS_HOST: redis
  REDIS_PORT: 6379
  REDIS_DB: 0
  # SEKRET:
  REDIS_PASSWORD: ${REDIS_PASSWORD}

  # Celery - używa hasła Redis
  CELERY_BROKER_URL: redis://:${REDIS_PASSWORD}@redis:6379/1

  # Storage - lokalne pliki
  STORAGE_TYPE: opendal
  OPENDAL_SCHEME: fs
  OPENDAL_FS_ROOT: storage

  # Vector Store - Weaviate
  VECTOR_STORE: weaviate
  WEAVIATE_ENDPOINT: http://weaviate:8080
  # SEKRET:
  WEAVIATE_API_KEY: ${WEAVIATE_API_KEY}

  # Sandbox
  CODE_EXECUTION_ENDPOINT: http://sandbox:8194
  # SEKRET:
  CODE_EXECUTION_API_KEY: ${CODE_EXECUTION_API_KEY}

  # SSRF Proxy
  SSRF_PROXY_HTTP_URL: http://ssrf_proxy:3128
  SSRF_PROXY_HTTPS_URL: http://ssrf_proxy:3128

services:
  # ===================================
  # API Service
  # ===================================
  api:
    image: langgenius/dify-api:1.9.2
    restart: always
    environment:
      <<: *shared-api-worker-env
      MODE: api
      PLUGIN_REMOTE_INSTALL_HOST: localhost
      PLUGIN_REMOTE_INSTALL_PORT: 5003
      # SEKRET:
      INNER_API_KEY_FOR_PLUGIN: ${PLUGIN_DIFY_INNER_API_KEY}
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    volumes:
      - ./volumes/app/storage:/app/api/storage
    networks:
      - ssrf_proxy_network
      - default

  # ===================================
  # Worker Service
  # ===================================
  worker:
    image: langgenius/dify-api:1.9.2
    restart: always
    environment:
      <<: *shared-api-worker-env
      MODE: worker
      # SEKRET:
      INNER_API_KEY_FOR_PLUGIN: ${PLUGIN_DIFY_INNER_API_KEY}
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    volumes:
      - ./volumes/app/storage:/app/api/storage
    networks:
      - ssrf_proxy_network
      - default

  # ===================================
  # Worker Beat (Scheduler)
  # ===================================
  worker_beat:
    image: langgenius/dify-api:1.9.2
    restart: always
    environment:
      <<: *shared-api-worker-env
      MODE: worker_beat
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    volumes:
      - ./volumes/app/storage:/app/api/storage

  # ===================================
  # Web Service (Frontend)
  # ===================================
  web:
    image: langgenius/dify-web:1.9.2
    restart: always
    environment:
      CONSOLE_API_URL: ""
      APP_API_URL: ""
      NEXT_PUBLIC_COOKIE_DOMAIN: ""

  # ===================================
  # PostgreSQL Database
  # ===================================
  db:
    image: postgres:15-alpine
    restart: always
    environment:
      POSTGRES_USER: postgres
      POSTGRES_DB: dify
      PGDATA: /var/lib/postgresql/data/pgdata
      POSTGRES_MAX_CONNECTIONS: 100
      # SEKRET:
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - ./volumes/db/data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  # ===================================
  # Redis Cache
  # ===================================
  redis:
    image: redis:6-alpine
    restart: always
    command: >
      redis-server
      --requirepass ${REDIS_PASSWORD}
      --maxmemory 512mb
      --maxmemory-policy allkeys-lru
    volumes:
      - ./volumes/redis/data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

  # ===================================
  # Sandbox (Code Execution)
  # ===================================
  sandbox:
    image: langgenius/dify-sandbox:0.2.12
    restart: always
    environment:
      GIN_MODE: release
      WORKER_TIMEOUT: 15
      ENABLE_NETWORK: "true"
      HTTP_PROXY: http://ssrf_proxy:3128
      HTTPS_PROXY: http://ssrf_proxy:3128
      # SEKRET:
      API_KEY: ${CODE_EXECUTION_API_KEY}
    volumes:
      - ./volumes/sandbox/dependencies:/dependencies
    networks:
      - ssrf_proxy_network
      - default

  # ===================================
  # Plugin Daemon
  # ===================================
  plugin_daemon:
    image: langgenius/dify-plugin-daemon:0.3.3-local
    restart: always
    environment:
      DIFY_INNER_API_URL: http://api:5001
      # SEKRETY:
      SECRET_KEY: ${PLUGIN_DAEMON_KEY}
      DIFY_INNER_API_KEY: ${PLUGIN_DIFY_INNER_API_KEY}
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - ./volumes/plugin_daemon:/app/storage

  # ===================================
  # SSRF Proxy
  # ===================================
  ssrf_proxy:
    image: ubuntu/squid:latest
    restart: always
    entrypoint:
      - /bin/bash
      - -c
      - |
        # SSRF Proxy entrypoint - inline z embedded template (dla Portainer Git)

        echo "[ENTRYPOINT] re-create snakeoil self-signed certificate"
        if [ ! -f /etc/ssl/private/ssl-cert-snakeoil.key ]; then
            /usr/sbin/make-ssl-cert generate-default-snakeoil --force-overwrite > /dev/null 2>&1
        fi

        # Tail logs do stdout
        tail -F /var/log/squid/access.log 2>/dev/null &
        tail -F /var/log/squid/error.log 2>/dev/null &
        tail -F /var/log/squid/store.log 2>/dev/null &
        tail -F /var/log/squid/cache.log 2>/dev/null &

        # Generuj squid.conf z embedded template z podstawieniem zmiennych
        echo "[ENTRYPOINT] generating squid configuration from embedded template"
        cat <<'SQUID_CONF_TEMPLATE' | awk '{
            while(match($$0, /\$${[A-Za-z_][A-Za-z_0-9]*}/)) {
                var = substr($$0, RSTART+2, RLENGTH-3)
                val = ENVIRON[var]
                $$0 = substr($$0, 1, RSTART-1) val substr($$0, RSTART+RLENGTH)
            }
            print
        }' > /etc/squid/squid.conf
        acl localnet src 0.0.0.1-0.255.255.255
        acl localnet src 10.0.0.0/8
        acl localnet src 100.64.0.0/10
        acl localnet src 169.254.0.0/16
        acl localnet src 172.16.0.0/12
        acl localnet src 192.168.0.0/16
        acl localnet src fc00::/7
        acl localnet src fe80::/10
        acl SSL_ports port 443
        acl Safe_ports port 80
        acl Safe_ports port 21
        acl Safe_ports port 443
        acl Safe_ports port 70
        acl Safe_ports port 210
        acl Safe_ports port 1025-65535
        acl Safe_ports port 280
        acl Safe_ports port 488
        acl Safe_ports port 591
        acl Safe_ports port 777
        acl CONNECT method CONNECT
        acl allowed_domains dstdomain .marketplace.dify.ai
        http_access allow allowed_domains
        http_access deny !Safe_ports
        http_access deny CONNECT !SSL_ports
        http_access allow localhost manager
        http_access deny manager
        http_access allow localhost
        include /etc/squid/conf.d/*.conf
        http_access deny all

        http_port $${HTTP_PORT}
        coredump_dir $${COREDUMP_DIR}
        refresh_pattern ^ftp:		1440	20%	10080
        refresh_pattern ^gopher:	1440	0%	1440
        refresh_pattern -i (/cgi-bin/|\?) 0	0%	0
        refresh_pattern \/(Packages|Sources)(|\.bz2|\.gz|\.xz)$ 0 0% 0 refresh-ims
        refresh_pattern \/Release(|\.gpg)$ 0 0% 0 refresh-ims
        refresh_pattern \/InRelease$ 0 0% 0 refresh-ims
        refresh_pattern \/(Translation-.*)(|\.bz2|\.gz|\.xz)$ 0 0% 0 refresh-ims
        refresh_pattern .		0	20%	4320

        http_port $${REVERSE_PROXY_PORT} accel vhost
        cache_peer $${SANDBOX_HOST} parent $${SANDBOX_PORT} 0 no-query originserver
        acl src_all src all
        http_access allow src_all

        client_request_buffer_max_size 100 MB
        SQUID_CONF_TEMPLATE

        # Start squid
        /usr/sbin/squid -Nz
        echo "[ENTRYPOINT] starting squid"
        exec /usr/sbin/squid -f /etc/squid/squid.conf -NYC 1
    environment:
      HTTP_PORT: 3128
      COREDUMP_DIR: /var/spool/squid
      REVERSE_PROXY_PORT: 8194
      SANDBOX_HOST: sandbox
      SANDBOX_PORT: 8194
    networks:
      - ssrf_proxy_network
      - default

  # ===================================
  # Nginx Reverse Proxy
  # PORT 8100 - dla Nginx Proxy Manager
  # ===================================
  nginx:
    image: nginx:latest
    restart: always
    entrypoint:
      - /bin/bash
      - -c
      - |
        # Nginx entrypoint - inline z embedded templates (dla Portainer Git)
        export HTTPS_CONFIG=''
        export ACME_CHALLENGE_LOCATION=''

        # Zbierz wszystkie zmienne środowiskowe do envsubst
        env_vars=$$(printenv | cut -d= -f1 | sed 's/^/$$/g' | paste -sd, -)

        # Generuj nginx.conf z embedded template
        cat <<'NGINX_CONF_TEMPLATE' | envsubst "$$env_vars" > /etc/nginx/nginx.conf
        user  nginx;
        worker_processes  $${NGINX_WORKER_PROCESSES};

        error_log  /var/log/nginx/error.log notice;
        pid        /var/run/nginx.pid;

        events {
            worker_connections  1024;
        }

        http {
            include       /etc/nginx/mime.types;
            default_type  application/octet-stream;

            log_format  main  '$$remote_addr - $$remote_user [$$time_local] "$$request" '
                              '$$status $$body_bytes_sent "$$http_referer" '
                              '"$$http_user_agent" "$$http_x_forwarded_for"';

            access_log  /var/log/nginx/access.log  main;

            sendfile        on;
            keepalive_timeout  $${NGINX_KEEPALIVE_TIMEOUT};
            client_max_body_size $${NGINX_CLIENT_MAX_BODY_SIZE};

            include /etc/nginx/conf.d/*.conf;
        }
        NGINX_CONF_TEMPLATE

        # Generuj proxy.conf z embedded template
        cat <<'PROXY_CONF_TEMPLATE' | envsubst "$$env_vars" > /etc/nginx/proxy.conf
        proxy_set_header Host $$host;
        proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $$scheme;
        proxy_set_header X-Forwarded-Port $$server_port;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_buffering off;
        proxy_read_timeout $${NGINX_PROXY_READ_TIMEOUT};
        proxy_send_timeout $${NGINX_PROXY_SEND_TIMEOUT};
        PROXY_CONF_TEMPLATE

        # Generuj default.conf z embedded template
        cat <<'DEFAULT_CONF_TEMPLATE' | envsubst "$$env_vars" > /etc/nginx/conf.d/default.conf
        server {
            listen $${NGINX_PORT};
            server_name $${NGINX_SERVER_NAME};

            location /console/api {
              proxy_pass http://api:5001;
              include proxy.conf;
            }

            location /api {
              proxy_pass http://api:5001;
              include proxy.conf;
            }

            location /v1 {
              proxy_pass http://api:5001;
              include proxy.conf;
            }

            location /files {
              proxy_pass http://api:5001;
              include proxy.conf;
            }

            location /explore {
              proxy_pass http://web:3000;
              include proxy.conf;
            }

            location /e/ {
              proxy_pass http://plugin_daemon:5002;
              proxy_set_header Dify-Hook-Url $$scheme://$$host$$request_uri;
              include proxy.conf;
            }

            location / {
              proxy_pass http://web:3000;
              include proxy.conf;
            }

            location /mcp {
              proxy_pass http://api:5001;
              include proxy.conf;
            }

            $${ACME_CHALLENGE_LOCATION}
            $${HTTPS_CONFIG}
        }
        DEFAULT_CONF_TEMPLATE

        # Uruchom nginx
        exec nginx -g 'daemon off;'
    environment:
      NGINX_SERVER_NAME: _
      NGINX_HTTPS_ENABLED: "false"
      NGINX_PORT: 80
      NGINX_WORKER_PROCESSES: auto
      NGINX_CLIENT_MAX_BODY_SIZE: 100M
      NGINX_KEEPALIVE_TIMEOUT: 65
      NGINX_PROXY_READ_TIMEOUT: 3600s
      NGINX_PROXY_SEND_TIMEOUT: 3600s
    depends_on:
      - api
      - web
    ports:
      - "8100:80"  # Stały port dla NPM - bez zmiennych!

  # ===================================
  # Weaviate Vector Database
  # ===================================
  weaviate:
    image: semitechnologies/weaviate:1.27.0
    restart: always
    profiles:
      - weaviate
    volumes:
      - ./volumes/weaviate:/var/lib/weaviate
    environment:
      PERSISTENCE_DATA_PATH: /var/lib/weaviate
      QUERY_DEFAULTS_LIMIT: 25
      AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: "false"
      DEFAULT_VECTORIZER_MODULE: none
      CLUSTER_HOSTNAME: node1
      AUTHENTICATION_APIKEY_ENABLED: "true"
      AUTHENTICATION_APIKEY_USERS: hello@dify.ai
      AUTHORIZATION_ADMINLIST_ENABLED: "true"
      AUTHORIZATION_ADMINLIST_USERS: hello@dify.ai
      # SEKRET:
      AUTHENTICATION_APIKEY_ALLOWED_KEYS: ${WEAVIATE_API_KEY}

networks:
  ssrf_proxy_network:
    driver: bridge
  default:
    driver: bridge
